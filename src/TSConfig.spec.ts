import typescript from 'typescript';
import * as path from 'path';
import { outputFileSync, removeSync, pathExists, readFile } from 'fs-extra';

import { TSParseError, InvalidJsonError } from '@j.u.p.iter/custom-error';
import { InFilesCache } from '@j.u.p.iter/in-files-cache';

import { TSConfig } from '.';

const CONFIG_NAME = 'tsconfig.json';
const CACHE_FOLDER_NAME = 'cache';

const getValidConfigContent = () => (
  JSON.stringify({
    extends: path.resolve(__dirname, '..', 'node_modules/@j.u.p.iter/jupiter-scripts/dist/lib/config/tsconfig.json'),  
  })
);

const getInvalidConfigContent = () => (
  JSON.stringify({
    hello: "./src"
  })
);

const getInvalidJSONContent = () => 'invalidJsonContent';

const validateConfig = config => {
  expect(config).toHaveProperty('moduleResolution');
}

const cacheFolderPath = path.resolve(__dirname, CACHE_FOLDER_NAME);
const pathToConfig = path.resolve(__dirname, '..', CONFIG_NAME);

/**
 * Cache for the config is generated by the `@j.u.p.iter/in-files-cache` tool.
 *   We construct path to the cache file name, taking into account, how this tool
 *   works under the hood. In particularly, the name of the config will serve as the
 *   folder name for all files with cache for one concrete given config.
 *
 */
const generatePathToCachedFile = (fileContent) => {
  const inFilesCache = new InFilesCache(cacheFolderPath);
  const cacheFileName = inFilesCache.generateCacheFileName(fileContent, '.json');

  return path.resolve(
    __dirname, 
    CACHE_FOLDER_NAME, 
    CONFIG_NAME.replace('.json', ''), 
    cacheFileName,
  );
};

describe('TSConfig', () => {
  afterEach(async () => {
    removeSync(cacheFolderPath);
    removeSync(pathToConfig);
  });

  it('throws an error if there is no such a config', async () => {
    const tsConfig = new TSConfig({
      cacheFolderPath,
      ts: typescript,
      configPath: CONFIG_NAME,
    });

    await expect(
      tsConfig.parse()
    ).rejects.toThrow(`File ${pathToConfig} does not exist`);
  });

  it('reads config by provided config path and create cache folder by provided path', async () => {
    outputFileSync(
      pathToConfig,
      getValidConfigContent(),
      'utf8'
    );

    const tsConfig = new TSConfig({
      cacheFolderPath,
      ts: typescript,
      configPath: CONFIG_NAME,
    });

    await expect(pathExists(cacheFolderPath)).resolves.toBe(false);

    const parsedConfig = await tsConfig.parse();

    validateConfig(parsedConfig);

    await expect(pathExists(cacheFolderPath)).resolves.toBe(true);

    const cachedFileContent = await readFile(generatePathToCachedFile(getValidConfigContent()), 'utf8');
    expect(parsedConfig).toEqual(JSON.parse(cachedFileContent));
  });

  it('throws an error if the config is invalid', async () => {
    outputFileSync(
      pathToConfig,
      getInvalidConfigContent(),
      'utf8'
    );

    const tsConfig = new TSConfig({
      cacheFolderPath,
      ts: typescript,
      configPath: CONFIG_NAME,
    });

    await expect(tsConfig.parse()).rejects.toThrow(TSParseError);
  });

  it('throws an error if config contains invalid json data', async () => {
    outputFileSync(
      pathToConfig,
      getInvalidJSONContent(),
      'utf8'
    );

    const tsConfig = new TSConfig({
      cacheFolderPath,
      ts: typescript,
      configPath: CONFIG_NAME,
    });

    const parseResult = tsConfig.parse();

    await expect(parseResult).rejects.toThrow(InvalidJsonError);
    await expect(parseResult).rejects.toThrow(`JSON data in "${pathToConfig}" is not valid`);
  });

  it('returns cached data instead of reading a config', async () => {
    const originalConfigContent = getValidConfigContent();
    const invalidConfigContent = getInvalidConfigContent();

    /**
     * Creates original config to parse and cache. 
     */
    outputFileSync(pathToConfig, originalConfigContent, 'utf8');

    /**
     * Creates cached version of previously created config
     *   with incorrect content to be able to check, that 
     *   we read in reality from the config.
     *
     */
    outputFileSync(generatePathToCachedFile(originalConfigContent), invalidConfigContent, 'utf8');

    const tsConfig = new TSConfig({
      cacheFolderPath,
      ts: typescript,
      configPath: CONFIG_NAME,
    });

    await expect(tsConfig.parse()).resolves.toBe(invalidConfigContent);
  });
});
